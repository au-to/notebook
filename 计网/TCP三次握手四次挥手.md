对于TCP的三次握手和四次挥手，最主要的是关注TCP头部的序列号、确认号、标记位（SYN/FIN/ACK/RST）

* 序列号：在初次建立连接时，客户端和服务端都会为本次连接随机初始化一个序列号；序列号可以用来解决网络包乱序的问题
* 确认号：接收端告诉发送端对上一个数据已经成功接收的消息，确认号用来解决网络丢包的问题
* 标记位：SYN为1表示希望建立连接，FIN为1表示希望断开连接，ACK为1表示确认号字段有效，RST为1表示TCP连接出现异常，需要断开

TCP三次握手

* TCP三次握手的过程其实就是在确认通信双方的序列号
* 就是双方都把自身的序列号发给对方，看对方能不能接收到。如果确认可以，那就可以正常通信；三次握手就是在确认双方是否具有收发数据的能力
* 基本过程
  1. 开始时，双方都处于close的状态
  2. 服务器主动监听某个端口，处于listen状态
  3. 客户端随机生成一个序列号，并把标志位设置为SYN（希望建立连接），然后把该报文发给服务端
  4. 客户端发完报文以后就进入SYN_SEND状态
  5. 服务端收到客户端请求后，也初始化相应的序列号
  6. 服务端把ACK和SYN都置为1，然后把该报文回发给客户端，服务端的状态变成 SYN-REVD 状态
  7. 客户端收到服务端发送的报文后，就知道服务端已经接收到了自己的序列号（通过确认号就可以知道），并且接收到了服务端的序列号
  8. 此时，客户端需要告诉服务端自己已经接收到了他发过来的序列号，所以在「确认号」字段上把标记位ACK置为1
  9. 客户端在发送报文之后，进入 ESTABLISHED 状态，而服务端接收到客户端的报文之后，也进入 ESTABLISHED 状态
* 简单总结
  * 第一次握手：客户端发送SYN请求建立连接
  * 第二次握手：服务端争对收到的SYN回送ACK，以及向客户端发送SYN请求建立连接
  * 第三次握手：客户端争对收到的SYN回送ACK
* 两次握手为啥不行
  * 两次握手只能保证客户端的序列号成功被服务端接收，而服务端无法确认自己的序列号是否被客户端成功接收

TCP四次挥手

* 基本过程
  1. 客户端打算关闭连接，会发 FIN 报文给服务端，客户端发送完之后，就进入FIN_WAIT_1状态
  2. 服务端收到 FIN 报文之后，回复 ACK 报文给客户端（表示已经收到了），服务端发送完之后，就进入 CLOSE_WAIT状态
  3. 客户端接收到服务端的 ACK 报文，就进入了 FIN_WAIT_2 状态
  4. 这时候，服务器可能还有数据要发送给客户端，等服务端确认自己已经没有数据返回给客户端之后，就发送FIN报文给客户端，自己进入 LAST_ACK 状态
  5. 客户端收到服务端的FIN报文之后，回应ACK报文，自己进入 TIME_WAIT 状态
  6. 服务端收到客户端的ACK报文之后，服务端就进入 CLOSE 状态
  7. 客户端在TIME_WAIT等到2MSL，也进入了 CLOSE 状态
* 简单总结
  * 第一次挥手：客户端向服务器发送FIN包，请求断开连接
  * 第二次挥手：服务端争对收到的FIN回送ACK
  * 第三次挥手：服务器向客户端发送FIN包，请求断开连接
  * 第四次挥手：客户端争对收到的FIN回送一个ACK
* 为啥需要四次
  * 其实很好理解，当客户端第一次发送 FIN 报文之后，只是代表着客户端不再发送数据给服务端，但此时客户端还是有接收数据的能力的。而服务端收到FIN报文的时候，可能还有数据要传输给客户端，所以只能先回复 ACK给客户端
  * 等到服务端不再有数据发送给客户端时，才发送 FIN 报文给客户端，表示可以关闭了
  * 所以，一来一回就四次了。