## ✅ 一、常见的拆包粒度策略

粒度指的是：\*\*你想拆成多少包，每一包包含哪些内容。\*\*粒度粗会减少请求数量，但牺牲按需性；粒度细会提升并发、复用性，但可能增加请求数。

### 🧩 1. 按依赖库拆包（vendors 拆包）

**优点**：第三方库变动小，可长期缓存
**做法**：把 `react`、`vue`、`lodash` 等拆出来

```js
// Webpack 示例
cacheGroups: {
  react: {
    test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
    name: 'react',
    priority: 20
  }
}
```

---

### 📂 2. 按业务模块拆包（页面级拆包）

**优点**：用户访问哪个页面，就加载哪个 chunk；**路由懒加载最佳搭配**

```js
const UserPage = () => import('@/views/UserPage.vue')
```

Vite/Webpack 自动拆成 `userPage.[hash].js`

---

### 🧱 3. 按组件拆包（细粒度）

**优点**：组件级懒加载、用于弹窗、Tab 页等
**缺点**：粒度太细可能造成请求碎片过多

```js
const BigChart = defineAsyncComponent(() => import('./BigChart.vue'))
```

---

### ⚙️ 4. 拆 runtime（运行时）和 manifest

将 Webpack 的运行时逻辑拆成独立文件，有助于浏览器更好地缓存业务逻辑。

```js
runtimeChunk: {
  name: 'runtime'
}
```

---

## 🚨 二、拆包的风险与误区

### 1. ❌ 过度拆包 → 导致“请求风暴”

拆太细，导致页面初次加载触发十几个请求，反而变慢。

* **浏览器并发限制**（大多为 6 个/域名）
* 小文件加载成本高，HTTP/1.1 下尤为明显（HTTP/2 较好）

**建议**：

* 小于 20KB 的模块，不建议单独拆包
* 控制 chunk 数量与大小，结合实际访问路径设计

---

### 2. ❌ 拆错粒度 → 缓存命中失败

把频繁变动和不变的代码混在一个 chunk 中，导致缓存失效。

例如：把 UI 框架和业务逻辑放一个包 → 一改业务就失效全包缓存。

---

### 3. ❌ 拆包策略固定死板

* 不同项目适用的策略不同
* 比如：后台系统模块独立性强 → 可以大胆拆包
* 移动端或单页应用 → 更应控制 chunk 数

---

## 🧠 总结建议

| 粒度类型       | 推荐场景          | 注意事项               |
| ---------- | ------------- | ------------------ |
| 依赖库拆包      | 所有项目          | 抽出稳定依赖，利于缓存        |
| 页面级拆包      | 多页、路由系统       | 懒加载提升体验            |
| 组件级拆包      | 弹窗、大组件、低频组件   | 控制数量，防止碎片化         |
| runtime 拆包 | 所有 Webpack 项目 | 拆出 runtime 提升缓存命中率 |

---