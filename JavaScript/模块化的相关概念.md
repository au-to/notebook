##### 模块模式

* 逻辑分块、各自封装、相互独立；每个块自行决定向外暴露什么，同时决定引入哪些外部代码
* 模块系统的本质是键值实体

##### 模块标识符

* 每个模块都对应一个用于引用它的标识符
* 可以是字符串、实际文件路径、文件名

##### 模块依赖

* 模块系统的核心是管理依赖
* 本地模块向模块系统声明一组外部依赖，这些外部依赖对当前模块的正常运行是必须的
* 模块系统检视这些依赖，并保证这些外部模块能够被加载并在本地模块运行时初始化所有的依赖

##### 模块加载

* 从入口模块递归的评估并加载所有的依赖
* 只有整个依赖图都加载完成，才可以执行入口模块

##### 入口

* 模块依赖的入口，代码执行的起点
* 模块的加载是阻塞的，只有前置操作完成才能执行后续操作

##### 异步依赖

* 按需加载
* js引擎告知模块系统在必要时才加载模块，并在加载完成后提供回调

##### 动态依赖

* 允许在程序结构中动态添加依赖

##### 静态分析

* 模块中的代码经常会被静态分析，分析工具会检查代码结构，并在不实际执行代码的情况下推断它的行为

##### 循环依赖

* a模块依赖b，b依赖a

**CommonJS**

* 主要用于在服务端实现模块化代码组织，不能在浏览器中直接运行
* 使用require()指定依赖，使用expors()对象定义自己的公共API
* 模块第一次加载后会被缓存，后续加载会取得缓存的模块，加载顺序由依赖图决定
* 可以使用module.exports()对象灵活导出
* 使用的是同步加载
* 如果一个模块的对外接口，就是一个单一的值，不能使用 exports 输出，只能使用 module.exports 输出。

**ES6**

模块标签：

* es6模块是作为一整块js代码而存在的，带有<script type="module">标签告知浏览器代码应该作为模块执行
* 像defer一样桉顺序加载，但执行会延迟到文档解析完成

模块加载流程

* 浏览器解析入口模块，确定依赖，并发送对依赖模块的请求
* 依赖文件通过网络返回，浏览器继续解析他们的内容，确定是否有二级依赖，从而发送更多的依赖请求
* 递归的调用，直到整个依赖图加载完成
* 依赖图解析完毕，应用程序开始正式加载模块

模块导出

* 使用export关键字：命名导出
* 默认导出：default export

模块导入

* import关键字导入，会被提升到模块顶部
* 模块标识符可以是相对于当前模块的相对路径，也可以是指向文件的绝对路径
* 导入对模块而言是只读的

 **ES6 module 和 CommonJS module 的区别**

* CommonJS的 require 语法是同步的，所以就导致了CommonJS模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 
* CommonJS 模块输出的是一个值的拷贝，而ES6 模块输出的是值的引用
* CommonJS 模块是运行时加载，而ES6模块是编译时输出接口，使得对JS的模块进行静态分析成为了可能
* 因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。CommonJS 遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，不会影响已经输出的变量。而ES6模块相反，使用 import 加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值
* 关于模块顶层的 this 指向问题，在CommonJS顶层， this 指向当前模块；而在ES6模块中， this 指向 undefined 
* 关于两个模块互相引用的问题，在ES6模块当中，是支持加载CommonJS模块的。但是反过来， CommonJS并不能 require ES6模块，在NodeJS中，两种模块方案是分开处理的