争对高频率执行js代码的一种优化手段；js中的一些事件如浏览器的resize、scroll事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。

### 防抖

在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。即：如果连续快速的触发，只会执行一次。

原始版本：timer只能在setTimeout的父级作用域中，没有将整个防抖函数封装在一起

``` 
var timer; //维护一个timer
function debounce(fun,time){
	clearTimeOut(timer);
	timmer = setTimeout(() => {
                fn();
            }, time);
	}
```

使用闭包封装整个防抖函数

``` 
function debounce(fun,time) {
let timer;
return function(){
clearTimeout(timer);
timer = setTimeout(()=>{
fun.apply(this,arguments)
     },time)
  }
}
```

### 节流

在规定的时间范围内不会重复触发回调，每隔一段时间，只执行一次回调。

```
function throttle(fun,time) {
  let t1 = 0;//初始时间
  return funtion() {
  	var _this = this;
  	var agrs = arguments;
  	let t2 = new Date();//当前时间
  	if(t2-t1>time) {
			fun.apply(_this,args);
			t1 = t2;
			}
		}
	}
```

### 区别

防抖：用户操作很频繁，但只执行一次

节流：用户操作很频繁，但把频繁的操作变为少量的操作，可以给浏览器充足的时间解析代码

