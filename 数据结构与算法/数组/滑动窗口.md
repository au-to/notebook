### 基本原理

滑动窗口，是借助一个可移动的区间通过滑动的方式依次框选元素，从而进行动态检索和求解。

滑动窗口的核心思想包括 **滑动** 以及 **动态求解** 两部分：

（1）滑动：窗口的滑动行为相当于移动的队列，每次滑动时，一端在出队，而另一端在入队。

（2）动态求解：每次滑动后，根据题意分析当前窗口值（比如窗口里元素的和），动态计算并更新结果。

假设给定一个数组 [1,2,3,4,1] ，如果要求长度为3的子数组和的最大值（即窗口大小为 3 ），滑动求解过程为：

* 初始化窗口状态 [1,2,3] 和结果值 ans=-Infinity，此时和为 1+2+3=6，结果值 ans=max{ans, 6}=6
* 向右滑动一次后，窗口左端元素1将出队，而滑动到的元素4将入队，窗口变成 [2,3,4]，此时和为 2+3+4=9，结果值为 ans=max{ans, 9}=9
* 再向右滑动一次后，窗口变为 [3,4,1]，和为 3+4+1=8，结果值为 ans=max{ans, 8}=9
  发现此时窗口已抵达数组最右端，停止滑动，返回结果值 ans=9

以上是窗口大小固定的滑动问题，实际上还有大小非固定的情况，比如寻找符合条件的最小长度子数组等，对于这类问题，则需要根据题意采用 寻找可行解 + 优化可行解 的步骤进行求解，具体见基本框架。

### 基本框架

从示例中可以看到需要确定的基本量是窗口范围，而窗口范围是动态变化的，因此可以利用双指针来确定：一端指向窗口左边索引，另一端指向窗口右边索引。

对于滑动窗口问题，以向右滑动为例，基本框架如下：

 （1）初始化：初始化窗口范围左右指针 left=right=0（即窗口范围为 [left, right]）以及结果值 ans
 （2）模拟滑动过程，直至右端达到最尽头，返回结果值
 	（3）寻找可行解：不断扩大窗口右端范围（right++），动态计算此时窗口元素序列的相关指标值，直至指标值符合题			  目要求
 	（4）优化可行解：窗口元素序列指标值达到题目要求后，不断增大窗口左端范围（left++）以缩小窗口长度，直至窗		      口元素指标值不符合题目要求。需要留意的是，在此过程中需要动态更新题目结果值。

### 题目示例

给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例1 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 符合条件的最小长度子数组为 [4,3]
示例2 输入：target = 4, nums = [1,4,4] 输出：1
示例3 输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0
对于该题，直接采用滑动窗口求解框架：

S1 初始化：初始化左右指针 left=right=0 以及结果值 ans=Infinity，同时还需要一个记录当前和的变量 sum=0
S2 模拟滑动过程，while(right<nums.length)
	S3 寻找可行解：逐步滑动右端指针，将指向的元素加入到窗口中 sum+=nums[right++]，直至sum>=target
	S4 优化可行解：根据当前可行解更新结果值 ans=min{ans, 当前窗口大小right-left}，逐步增大左端指针以缩小窗口，并		  动态更新当前窗口和 sum-=nums[left++]，直至 sum<target
		  判断 ans 是否被更新，即是否找到了可行解（因为找到可行解时，ans!=Infinity），如是返回结果值，否则返回 0

``` 
var minSubArrayLen = function (target, nums) {
    const n = nums.length;

    // S1 初始化窗口左右指针、窗口长度结果以及当前窗口和
    let left = 0;
    let right = 0;
    let ans = Infinity;
    let sum = 0;

    // S2 模拟像右滑动
    while (right < n) {
        // S3 寻找可行解
        sum += nums[right];
        right++;

        // S4 当已找到可行解时，缩小窗口以优化
        while (sum >= target) {
            // S4-1 更新结果值
            ans = Math.min(ans, right - left);
            // S4-2 缩小窗口
            sum -= nums[left];
            left++;
        }
    }
}
```

