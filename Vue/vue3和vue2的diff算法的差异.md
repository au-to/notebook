这是一个非常有深度的问题。Vue 3 和 Vue 2 在 **Virtual DOM 的 Diff 算法** 方面确实做了大量优化，虽然核心思想相似，但在性能和设计上有明显区别。

---

## 🧠 1. Vue 2 的 Diff 算法

### 核心特点：

* Vue 2 使用的是 **双端比较**（头尾指针法），对比新旧子节点数组。
* 在 patch 阶段通过 `sameVnode()` 函数判断两个 VNode 是否为“同一个节点”（通常通过 `key` 和 `tag`）。
* 处理方式包括：

  * 头对头、尾对尾、头对尾、尾对头 比较
  * 找不到对应就重新创建或删除节点

### 问题：

* **时间复杂度仍为 O(n²)**（最坏情况下）
* 在遇到大量有 key 的子节点调换顺序时，会产生多余的 DOM 操作

---

## 🚀 2. Vue 3 的优化点（重点来了）

Vue 3 在 Diff 算法方面做了多项优化，主要目标是 **减少不必要的 DOM 操作、提高 patch 性能**。

### ✅ 核心优化点：

---

### 📌（1）使用最长递增子序列（**LIS 算法**）

> 减少 DOM 移动操作

* 当两个子节点列表有大量位置变化时，Vue 3 会使用 `LIS` 算法找出哪些节点“位置不变”，这些节点 **不需要移动**，从而减少 patch 代价。
* 其余节点再做移动或新增/删除。

#### 🧠 示例：

```js
旧：[a, b, c, d]
新：[d, a, b, c]

Vue 2：可能会全量 patch（重新排序）
Vue 3：识别 a,b,c 位置未变，d 移动到前面
```

---

### 📌（2）静态节点提升（Static Tree Hoisting）

> 编译阶段就识别不变的节点，跳过对比

* 对静态内容不做 patch，**跳过比对过程**。
* 对性能提升明显（尤其在静态列表/结构多的模板中）

---

### 📌（3）Patch Flag 标记位优化

> 编译阶段给动态内容打标记，**运行时只对需要更新的部分做 diff**

* Vue 3 编译器会在生成 VNode 时，**标记哪些地方是动态的**。
* 运行时 diff 算法可跳过大部分静态部分。

#### ✅ 示例：

```html
<!-- Vue 3 编译后标记哪些地方是动态的 -->
<div>{{ msg }}</div>
```

变成：

```js
createVNode('div', null, msg, PatchFlags.TEXT)
```

---

### 📌（4）Fragment 支持更强

> Vue 3 支持多个根节点，diff 时可以处理更复杂结构

---

### 📌（5）更好的 Keyed Diff 策略

> Vue 3 中 key 的 diff 更精确，不再简单使用 `sameVnode()`，而是配合位图策略和偏移优化。

---

## 🧾 总结对比表：

| 特性          | Vue 2          | Vue 3                |
| ----------- | -------------- | -------------------- |
| Diff 算法核心   | 双端对比           | 快速头尾对比 + LIS 最长递增子序列 |
| 静态节点优化      | 没有             | 编译期静态提升              |
| Patch 标记优化  | 没有             | PatchFlags 精确标记动态部分  |
| Fragment 支持 | 不支持多个根节点       | ✅ 支持                 |
| 性能          | 较好，但面对复杂结构效率不高 | 明显提升，适合大规模渲染场景       |

---