项目搭建

* 前后端分离开发
* Vue-cli4.5初始化项目

静态文件

* public：打包时不压缩
* assets：打包压缩

项目其它配置

* 关闭eslint（vue.config.js）
* 重新配置src别名为@（jsconfig.json）；注意：在node_modules和dist文件夹下不能使用@

项目路由分析

* home路由、search路由、login路由（无footer）、register路由（无footer）
* header、footer为非路由组件

依赖

* 需要安装less和less-loader依赖

配置路由

* pages文件夹放置路由组件
* 在单独文件夹中配置：router>index.js
* 需要在main.js中注册路由，所有组件都可以访问到以下两个对象
* $route：获取query、params等参数
* $router：进行路由导航
* 申明式导航、编程式导航（可以进行额外的操作）

Footer组件的显示与隐藏

* $route.path结合v-show
* 路由元信息

路由传参

* params参数：路径中需要占位（/:id）
* query参数：不属于路径中的信息（?k=v）
* 字符串传递或者模板字符串`${}`
* 对象写法

遇到的问题

* 收集首页搜索框输入的数据，并作为pramas参数，使用编程式导航跳转到search路由；
* 之后在搜索路由下再次搜索时需要重新收集数据，无法使用之前收集的数据

路由传参相关面试题

* 路由传参的写法有几种：3种（模板字符串、字符串拼接、对象）
* 对象写法中的path不能和params参数一起使用，需要name命名
* 如果路由要求传递params参数，但没有传，则路由会出现问题（路径显示不全）
* 在配置路由时，占位后面加上？，代表params参数可传可不传
* 如果传递空串，如何解决？使用undefined

路由组件传参（props）

* 给谁传就写在哪个组件上
* 布尔值写法：`props: true`；只能传params参数
* 对象写法：额外传递一些props，值固定
* 函数写法：可以传params参数和query参数

编程式路由导航跳转路由，多次点击出现错误提示

* vue-router3.5.3引入了promise
* 给push传入一个回调
* 重写vueRouter原型对象上的push和replace方法

home首页

* 注册三级联动为全局组件（home、search、detail都使用）

axios二次封装

* 添加请求拦截器（请求之前）和响应拦截器（服务器数据返回前）
* 建立api文件夹>=request.js
* 请求拦截器：config配置对象包含headers请求头

api接口统一管理

* api >= index.js；利于复用
* 每个请求封装为一个函数，外部调用即发请求
* axios返回一个promise对象

解决跨域

* 违背了浏览器同源策略（协议，端口号，域名）
* 解决：jsonp、cors、代理（服务器与服务器）
* webpack的devserver配置代理跨域（vue.config.js==webpack.config.js）

vuex状态管理

* 模块式开发

三级联动动态改变背景颜色

* 鼠标进入动态添加类名
* 鼠标移出使用事件委派，移除类名

防抖解决卡顿

* 鼠标快速滑过所有的一级分类，触发鼠标进入事件
* 用户操作过快时，只有部分一级分类上的鼠标进入事件触发，出现卡顿现象

三级联动路由跳转和传参

* 声明式导航出现卡顿；因为router-link是一个组件，当服务器返回的一级分类很多时，会出现卡顿
* 事件委派：点击事件放在父元素；避免v-for往每一个a标签都添加事件处理函数
* 给子节点a标签加自定义属性，区分a标签和其它标签
* 编程式导航+事件委派+自定义属性

search搜索模块

* tapNav时而显示，时而隐藏
* 路由跳转会导致组件的多次创建和销毁，mouted()内多次重发请求
* 将获取商品分类的派发请求放在App.vue组件中，这样只会发一次请求，节省性能

Mockjs插件模拟数据

* 引入Mockjs模块
* 引入Json数据
* webpack默认对外暴露：图片、Json
* 在main.js中引入封装的mockServe.js文件
* 在api下单独封装一个mock的ajax

banner轮播图

* swiper插件
* 引入js和css文件
* 在new swiper实例之前，必须有dom结构
* 完美的解决方案：watch监听数据属性的变化，加$nextTick()，在dom渲染完毕new swiper实例

search模块开发

* mounted中的数据请求只会发一次（挂载成功时）
* 可以把请求封装为一个函数，供组件调用
* 需要和合并参数（当前组件实例上的query参数和params参数，以及search页需要传递的参数），向服务器发起请求
* 解决请求只会发一次的问题：监听组件的$route路由属性，当$route发生变化，再次发请求
* 每一次请求时，都应该把上一次的id置空

详情模块开发

* 点击商品，跳转到详情页，路由跳转时需要带上产品id给详情页
* 滚动条：使用vue-router滚动行为
* 派发action：点击图片跳转至详情页时（即detail组件挂载完毕时）
* 点击哪个产品的售卖属性，谁就高亮，排他思想

放大镜

* 组件传参，父传子

详情页选择购买产品个数

* 收集产品个数（v-model）
* 用户可以点击加减，或者手动输入，但不能出现负数，所以减时要设置权限（分情况）
* 给input绑定change事件，监听用户输入
* event.target.value获取用户输入的值，依然不能是负数或小数...
* 可以通过*1判断用户输入是不是数字
* isNaN()判断非法 >= skuNum=1；<1 同样非法
* 也不能是小数：parseint()取整
* 只有>1的正整数满足条件

加入购物车

* 点击加入购物车跳转至加入购物车成功或者失败的路由
* 跳转之前需要发请求，告诉服务器买了什么，买了多少，让服务器存储信息
* 加入购物车成功或失败的路由需要展示产品信息
* 加入购物车，可能添加成功（传递参数>=产品id和购买个数，并进行路由跳转），也可能添加失败（提醒用户）
* 加入购物车，服务器并不返回数据，只返回添加成功或失败的结果，所以没必要store存储

加入购物车成功与失败的判断

* 发请求之后，成功或失败的结果在store仓库，但我们需要在组件内使用
* 可以把结果存储在仓库中，在组件内获取
* 也可以使用promise：异步请求的操作返回实质是一个promise

加入购物车成功路由

* 路由跳转时需要把产品信息带过去在新路由组件中进行展示
* 由于产品信息数据结构很复杂，不适合通常的传参方式（可以，但路径不好看）
* 解决：使用会话存储产品信息，把详情页信息给加入成功的组件使用
* 为啥不用本地存储：不需要持久存储，只需要展示一次，会话结束即丢掉数据，单页应用适合
* 简单的产品个数则直接使用query传参就行
* 本地存储和会话存储不可以存储对象，需要转为字符串

uuid游客获取购物车数据

* 用户添加购物车时，需要告诉服务器你是谁，因为每个用户的购物车是不一样的
* 如果不给，那么服务器无法根据特定用户返回购物车数据进行展示
* 所以在添加购物车时，需要给购物车加一个身份，uuid派上用场（临时游客身份）
* uuid用于生成唯一字符串作为身份标识
* 如何给服务器带临时身份呢？>= header请求头 >= 请求拦截器
* uuid()每次执行都会有一个新的值，但游客身份不能变
* 使用本地存储持久存储，先检查本地存储是否有uuid，没有再进行存储
* 在请求头添加一个字段（不能瞎写，需要后端做配置）

用法

* 封装一个getUUID函数，生成的uuid字符串唯一的存储在本地存储中，在detail仓库中调用函数，并把值存储在仓库中
* 获取存储在仓库的uuid字符串值，放在header请求头中
* 这样在detail组件声明周期内发的请求都会带上唯一的uuid，添加购物车自然就有唯一标识了

购物车动态展示数据

* 产品数据展示
* 是否选中，checked属性，后端也会返回一个是否选中的标识：isChecked
* 全选：遍历把每一个产品的选中状态改为1，同时改变input下的checked属性
* 总价计算：forEach遍历

修改购物车产品个数

* 处理产品数量：改变购物车内的产品个数就需要发请求（比如加1减1）
* 加减改都用同一个回调，如何区分回调作用于哪一个身上呢：传递不同的实参
* 有三种不同的状态
* 每次修改数据之后都需要再次向服务器发请求，进行展示最新的数据
* 使用节流优化点击事件，频发发起网路请求的情况

删除购物车商品

* 根据商品id删除商品
* 只需要知道删除成功或者失败就行
* 服务器不返回数据
* 使用节流优化点击事件

修改某个商品的勾选状态

* 需要向服务器发请求
* 给表单chenge事件添加回调

删除选中的全部产品（难点）

* 在dom只派发一次action >= deleteAllCheckedCarts()，在这个函数中再多次派发有删除操作的action
* 本质就是多次调用删除某一商品的那个action，但应该只是删除选中的商品
* 根据context上下文的state，来获取商品的选中状态，进行遍历删除即可
* 每一项执行删除返回的结果都放进数组中，统一给promise.all()
* 返回promise.all()，都返回成功了，则删除成功

全部产品的勾选状态修改

* 点击全选需要向服务器发请求，告知服务器商品的checked状态变为1

注册

* ~@可以在css中使用，代表src
* 收集表单数据：手机号，密码，确认密码，验证码，是否同意协议等
* 点击获取验证码，带上手机号发请求获取验证码
* 把验证码存在仓库中
* 点击完成注册，发请求，把相关信息带给服务器
* 注册成功，跳转路由到登录页，失败还是在注册页

登录

* 登录的前提是先注册
* 收集用户名和密码，携带这俩参数向服务器发请求
* 阻止form表单的默认行为.prevent
* 登录成功，服务器会返回一个token（用于标识用户身份）
* 将返回的token存储在本地存储中
* 登录成功，跳转路由到首页

用户登录携带token获取用户信息

* 登录成功，路由跳转到首页，首页和其余页面需要动态展示用户信息，即登录状态
* 在APP组件的mouted下派发action，即获取用户信息，app只会挂载一次，用户信息会一直保留

退出登录

* 需要向服务器发请求，清除token
* 清除本地存储的用户信息，token等
* 点击退出登录，如果成功，路由跳转到首页

导航首位

* 在登录情况下，不能回到登录页面和注册页
* 如果可以拿到token，证明已经登录过了
* 所以根据token有无来作为条件进行导航控制
* 其次如果登录成功，需要在能拿到用户信息的情况下才能放行
* 在放行之前先获取用户信息再进行跳转
* 用户未登录，放行就可以
* 若token失效，清除token，重新登录

``` 
// 全局前置守卫
router.beforeEach((to, from, next) => {
  let token = store.state.user.token;
  let name = store.state.user.userInfo.name;
});

if (token) {
    // 登录时不能跳转至登录和注册
    if (to.path == '/login' || to.path == '/register') {
      next('/home');
    } else {
      // 登录了，但用户访问的不是登录和注册页面
      if (name) {
        next();
      } else {
        // 获取用户信息再放行
        store.dispatch('getUserInfo');
        next();
      }
    }
  } else {
    // 没有登录或者token过期
    // 清除token，重新登录
    store.dispatch('logOut');
    next('/home');
  }
```

提交订单

* 点击提交订单，发请求提交交易信息（交易编号）
* 成功的话，服务器会返回一个订单号
* 此处不用vuex管理数据，直接存储在组件内
* 把api接口请求函数挂载到vue的原型上，供组件直接调用
* 提交成功跳转到支付页面（带上订单号）

支付

* 展示订单号
* 带上订单号向服务器发请求，获取支付信息
* 点击微信支付
* 不允许给生命周期函数加async
* 服务器返回一个codeurl用于生成二维码，完成支付

微信支付

* qrcode二维码生成函数

* 点击立即支付，服务器返回一个字符串，使用qrcode函数生成二维码

* 支付可能成功也可能失败

* 弹框一出就需要一直发请求，带上订单号查询订单支付的结果

* 存储code防止未支付就跳转

* 此处需要长轮询

* ``` 
  let timer;
  if(!timer) {
  	setInterval(async()=>{
  		//发请求
  		let result = await ...
  		if(result.code==200){
  			// 清除定时器
  			clearInterval(timer);
  			timer = null;
  			// 关闭弹框
  		}
  	},delay)
  }
  ```

* 支付成功，再跳转路由

图片懒加载

* 服务器未返回数据前，显示默认的图片，数据返回后再显示相应的图片
* 提升用户体验
* vue-lazyload

自定义插件

* 插件一定对外暴露一个对象
* 必须为该对象定义一个install方法
* Vue.use()会调用install方法
