浏览器的垃圾回收机制（Garbage Collection, GC）主要针对 JavaScript 在内存中的自动管理。JavaScript 引擎（如 V8）会定期执行垃圾回收，清除不再使用的内存，防止内存泄漏，提高页面性能。

---

## 🧠 一、JavaScript 的内存结构

JavaScript 的内存分为两个主要部分：

| 区域      | 内容                  |
| ------- | ------------------- |
| **栈内存** | 存储基本类型数据、执行上下文、函数调用 |
| **堆内存** | 存储对象、数组、函数等引用类型数据   |

垃圾回收主要针对 **堆内存中不再被引用的数据**。

---

## 🔍 二、核心原理：标记-清除（Mark-and-Sweep）

这是现代 JavaScript 引擎（如 V8）使用的主要垃圾回收算法。

### 🌱 1. 过程如下：

1. **标记阶段**：从“根对象”（如全局对象 `window`）开始递归遍历，**标记所有可达对象**。
2. **清除阶段**：删除所有**未被标记**的对象（这些就是“垃圾”）。

> “可达”对象：有可能继续被访问的对象（在作用域链上、被闭包引用、在全局变量中等）。

### ✅ 示例

```js
function test() {
  const obj = { name: 'test' }; // 局部作用域内对象
}
test(); // 执行完后，obj 不再可达，GC 会回收它
```

---

## 🧩 三、引用计数算法（已不常用）

> 老的垃圾回收机制，如 IE 早期使用的是“引用计数”法。

* 每个对象维护一个计数器，被引用一次计数 +1，取消引用 -1。
* 当计数为 0 时，对象会被回收。

**缺点：无法处理循环引用：**

```js
const a = {};
const b = {};
a.b = b;
b.a = a; // 循环引用 ❌，计数永远不为 0，无法回收
```

---

## ⚙️ 四、V8 引擎的垃圾回收机制（Chrome）

V8 将堆内存分为两代：

| 内存区            | 描述                   | 回收方式                          |
| -------------- | -------------------- | ----------------------------- |
| 新生代（New Space） | 存储生命周期短的小对象（如局部变量）   | **Scavenge 算法**（复制+标记）        |
| 老生代（Old Space） | 存储生命周期长的大对象（闭包、全局变量） | **Mark-Sweep + Mark-Compact** |

### 🔄 新生代的 GC：Scavenge 算法

* 把内存分成 From 和 To 两个区域，活的对象复制到 To 区域，清空 From。
* 快速、低成本，适用于短生命周期对象。

### 📦 老生代的 GC：Mark-Sweep + Compact

* 标记、清除、整理（Compact）碎片。
* 比较耗时，但释放大量内存。

---

## ⚠️ 五、注意垃圾回收无法处理的场景

* **闭包长期引用变量**导致内存无法释放
* **事件监听器未解绑**
* **定时器未清除**
* **全局变量滥用**
* **DOM 引用未清除**

---

## 🧼 六、开发中的内存优化建议

* 减少全局变量使用
* 使用完定时器/事件监听后及时清除
* 谨慎使用闭包，避免持有大对象引用
* 工具辅助：Chrome DevTools 的 Memory 面板查看内存快照、泄漏、GC 触发等

---